use std::collections::{BTreeMap, BTreeSet};
use std::path::PathBuf;
use std::rc::Rc;
use std::time::{Duration, Instant};

use anyhow::Result;
use gpui::{
    Animation, AnimationExt as _, AnyElement, App, AppContext as _, Application, ClipboardItem,
    Context, Entity, FocusHandle, Hsla, InteractiveElement as _, IntoElement, IsZero as _,
    KeyBinding, ListAlignment, ListOffset, ListSizingBehavior, ListState, Menu, MenuItem,
    MouseButton, MouseDownEvent, MouseMoveEvent, MouseUpEvent, OsAction, ParentElement as _,
    PathPromptOptions, Render, ScrollWheelEvent, SharedString, StatefulInteractiveElement as _,
    Styled as _, SystemMenuType, Task, Timer, TitlebarOptions, Window, WindowOptions, actions, div,
    list, prelude::FluentBuilder as _, px,
};
use gpui_component::{
    ActiveTheme as _, Colorize as _, Root, StyledExt as _, Theme, ThemeMode, h_flex,
    highlighter::HighlightThemeStyle,
    input::InputState,
    menu::AppMenuBar,
    resizable::{h_resizable, resizable_panel},
    scroll::ScrollableElement,
    v_flex,
};
use gpui_component_assets::Assets;
use tracing::error;

use hunk::config::{AppConfig, ConfigStore, KeyboardShortcuts, ThemePreference};
use hunk::diff::{DiffCell, DiffCellKind, DiffRowKind, SideBySideRow};
use hunk::jj::{
    BookmarkRevision, ChangedFile, FileStatus, LineStats, LocalBranch, RepoSnapshotFingerprint,
};
use hunk::state::{AppState, AppStateStore};

use data::{
    DiffRowSegmentCache, DiffStreamRowMeta, FileRowRange, RepoTreeNode, RepoTreeRow, RightPaneMode,
    WorkspaceViewMode,
};

const AUTO_REFRESH_INTERVAL: Duration = Duration::from_millis(900);
const FPS_SAMPLE_INTERVAL: Duration = Duration::from_millis(250);
const AUTO_REFRESH_SCROLL_DEBOUNCE: Duration = Duration::from_millis(500);
const DIFF_MONO_CHAR_WIDTH: f32 = 8.0;
const DIFF_LINE_NUMBER_MIN_DIGITS: u32 = 3;
const DIFF_LINE_NUMBER_EXTRA_PADDING: f32 = 6.0;
const DIFF_MARKER_GUTTER_WIDTH: f32 = 10.0;
const APP_BOTTOM_SAFE_INSET: f32 = 0.0;
const DIFF_BOTTOM_SAFE_INSET: f32 = APP_BOTTOM_SAFE_INSET;
const DIFF_SCROLLBAR_RIGHT_INSET: f32 = 0.0;
const DIFF_SCROLLBAR_SIZE: f32 = 16.0;
const FILE_EDITOR_MAX_BYTES: usize = 2_400_000;
const DIFF_SEGMENT_PREFETCH_RADIUS_ROWS: usize = 120;
const DIFF_SEGMENT_PREFETCH_STEP_ROWS: usize = 24;
const DIFF_SEGMENT_PREFETCH_BATCH_ROWS: usize = 96;
const DIFF_PROGRESSIVE_BATCH_FILES: usize = 8;
const SIDEBAR_REPO_LIST_ESTIMATED_ROW_HEIGHT: f32 = 24.0;

mod controller;
mod data;
mod highlight;
mod render;

actions!(
    diff_viewer,
    [
        SelectNextLine,
        SelectPreviousLine,
        ExtendSelectionNextLine,
        ExtendSelectionPreviousLine,
        CopySelection,
        SelectAllDiffRows,
        NextHunk,
        PreviousHunk,
        NextFile,
        PreviousFile,
        ToggleSidebarTree,
        OpenProject,
        SaveCurrentFile,
        OpenSettings,
        QuitApp,
    ]
);

fn preferred_ui_font_family() -> &'static str {
    if cfg!(target_os = "macos") {
        ".SystemUIFont"
    } else if cfg!(target_os = "windows") {
        "Segoe UI"
    } else {
        "Inter"
    }
}

fn preferred_mono_font_family() -> &'static str {
    if cfg!(target_os = "macos") {
        "Menlo"
    } else if cfg!(target_os = "windows") {
        "Consolas"
    } else {
        "DejaVu Sans Mono"
    }
}

fn hsla_hex(hex: &str) -> Option<Hsla> {
    Hsla::parse_hex(hex).ok()
}

fn editor_highlight_style(
    base: Option<HighlightThemeStyle>,
    fallback: HighlightThemeStyle,
    mode: ThemeMode,
) -> HighlightThemeStyle {
    let mut style = base.unwrap_or(fallback);
    if mode.is_dark() {
        style.editor_background = hsla_hex("#20252f");
        style.editor_active_line = hsla_hex("#2a3140");
        style.editor_line_number = hsla_hex("#748094");
        style.editor_active_line_number = hsla_hex("#ced7e6");
    } else {
        style.editor_background = hsla_hex("#f4f6fa");
        style.editor_active_line = hsla_hex("#e7edf7");
        style.editor_line_number = hsla_hex("#8d97a8");
        style.editor_active_line_number = hsla_hex("#4a5363");
    }
    style
}

fn apply_soft_light_theme(cx: &mut App) {
    let mut light_theme = (*Theme::global(cx).light_theme).clone();
    let fallback_highlight = Theme::global(cx).highlight_theme.style.clone();

    // Reduce eye strain in light mode by shifting from pure white to a soft off-white palette.
    light_theme.colors.background = Some("#f5f6f8".into());
    light_theme.colors.list = Some("#f5f6f8".into());
    light_theme.colors.popover = Some("#f5f6f8".into());
    light_theme.colors.table = Some("#f5f6f8".into());
    light_theme.colors.sidebar = Some("#f5f6f8".into());
    light_theme.colors.title_bar = Some("#f5f6f8".into());
    light_theme.colors.list_even = Some("#f1f2f5".into());
    light_theme.colors.list_head = Some("#eef0f4".into());
    light_theme.colors.secondary = Some("#eceef3".into());
    light_theme.colors.secondary_hover = Some("#e4e7ee".into());
    light_theme.colors.secondary_active = Some("#dce1ea".into());
    light_theme.colors.muted = Some("#e9ecf2".into());
    light_theme.colors.muted_foreground = Some("#616977".into());
    light_theme.colors.border = Some("#d2d8e3".into());
    light_theme.font_family = Some(preferred_ui_font_family().into());
    light_theme.font_size = Some(14.0);
    light_theme.mono_font_family = Some(preferred_mono_font_family().into());
    light_theme.mono_font_size = Some(12.0);
    light_theme.radius = Some(8);
    light_theme.radius_lg = Some(10);
    light_theme.shadow = Some(false);
    light_theme.highlight = Some(editor_highlight_style(
        light_theme.highlight.clone(),
        fallback_highlight,
        ThemeMode::Light,
    ));

    Theme::global_mut(cx).light_theme = Rc::new(light_theme);

    if !Theme::global(cx).mode.is_dark() {
        Theme::change(ThemeMode::Light, None, cx);
    }
}

fn apply_soft_dark_theme(cx: &mut App) {
    let mut dark_theme = (*Theme::global(cx).dark_theme).clone();
    let fallback_highlight = Theme::global(cx).highlight_theme.style.clone();

    // Match a softer charcoal palette so colored diff cues stand out without eye strain.
    dark_theme.colors.background = Some("#1f2126".into());
    dark_theme.colors.list = Some("#1f2126".into());
    dark_theme.colors.popover = Some("#242831".into());
    dark_theme.colors.table = Some("#1f2126".into());
    dark_theme.colors.sidebar = Some("#1b1e24".into());
    dark_theme.colors.title_bar = Some("#1a1d22".into());
    dark_theme.colors.list_even = Some("#21242b".into());
    dark_theme.colors.list_head = Some("#292d36".into());
    dark_theme.colors.secondary = Some("#2a2f38".into());
    dark_theme.colors.secondary_hover = Some("#343b47".into());
    dark_theme.colors.secondary_active = Some("#3b4452".into());
    dark_theme.colors.muted = Some("#272c35".into());
    dark_theme.colors.muted_foreground = Some("#a3adbb".into());
    dark_theme.colors.border = Some("#3d4554".into());
    dark_theme.font_family = Some(preferred_ui_font_family().into());
    dark_theme.font_size = Some(14.0);
    dark_theme.mono_font_family = Some(preferred_mono_font_family().into());
    dark_theme.mono_font_size = Some(12.0);
    dark_theme.radius = Some(8);
    dark_theme.radius_lg = Some(10);
    dark_theme.shadow = Some(false);
    dark_theme.highlight = Some(editor_highlight_style(
        dark_theme.highlight.clone(),
        fallback_highlight,
        ThemeMode::Dark,
    ));

    Theme::global_mut(cx).dark_theme = Rc::new(dark_theme);

    if Theme::global(cx).mode.is_dark() {
        Theme::change(ThemeMode::Dark, None, cx);
    }
}

fn build_application_menus() -> Vec<Menu> {
    if cfg!(target_os = "macos") {
        vec![
            Menu {
                name: "Hunk".into(),
                items: vec![
                    MenuItem::os_submenu("Services", SystemMenuType::Services),
                    MenuItem::separator(),
                    MenuItem::action("Settings...", OpenSettings),
                    MenuItem::separator(),
                    MenuItem::action("Quit Hunk", QuitApp),
                ],
            },
            Menu {
                name: "File".into(),
                items: vec![
                    MenuItem::action("Open Project...", OpenProject),
                    MenuItem::action("Save File", SaveCurrentFile),
                    MenuItem::separator(),
                    MenuItem::action("Settings...", OpenSettings),
                ],
            },
            Menu {
                name: "Edit".into(),
                items: vec![
                    MenuItem::os_action("Copy", CopySelection, OsAction::Copy),
                    MenuItem::os_action("Select All", SelectAllDiffRows, OsAction::SelectAll),
                ],
            },
        ]
    } else {
        vec![
            Menu {
                name: "File".into(),
                items: vec![
                    MenuItem::action("Open Project...", OpenProject),
                    MenuItem::action("Save File", SaveCurrentFile),
                    MenuItem::action("Settings...", OpenSettings),
                    MenuItem::separator(),
                    MenuItem::action("Quit Hunk", QuitApp),
                ],
            },
            Menu {
                name: "Edit".into(),
                items: vec![
                    MenuItem::action("Copy", CopySelection),
                    MenuItem::action("Select All", SelectAllDiffRows),
                ],
            },
        ]
    }
}

fn load_keyboard_shortcuts() -> KeyboardShortcuts {
    let store = match ConfigStore::new() {
        Ok(store) => store,
        Err(err) => {
            error!("failed to initialize config path for keyboard shortcuts: {err:#}");
            return KeyboardShortcuts::default();
        }
    };

    match store.load_or_create_default() {
        Ok(config) => config.keyboard_shortcuts,
        Err(err) => {
            error!(
                "failed to load keyboard shortcuts from {}: {err:#}",
                store.path().display()
            );
            KeyboardShortcuts::default()
        }
    }
}

fn bind_keyboard_shortcuts(cx: &mut App, shortcuts: &KeyboardShortcuts) {
    let mut bindings = Vec::new();

    bindings.extend(
        shortcuts
            .select_next_line
            .iter()
            .map(|shortcut| KeyBinding::new(shortcut.as_str(), SelectNextLine, Some("DiffViewer"))),
    );
    bindings.extend(shortcuts.select_previous_line.iter().map(|shortcut| {
        KeyBinding::new(shortcut.as_str(), SelectPreviousLine, Some("DiffViewer"))
    }));
    bindings.extend(shortcuts.extend_selection_next_line.iter().map(|shortcut| {
        KeyBinding::new(
            shortcut.as_str(),
            ExtendSelectionNextLine,
            Some("DiffViewer"),
        )
    }));
    bindings.extend(
        shortcuts
            .extend_selection_previous_line
            .iter()
            .map(|shortcut| {
                KeyBinding::new(
                    shortcut.as_str(),
                    ExtendSelectionPreviousLine,
                    Some("DiffViewer"),
                )
            }),
    );
    bindings.extend(
        shortcuts
            .copy_selection
            .iter()
            .map(|shortcut| KeyBinding::new(shortcut.as_str(), CopySelection, Some("DiffViewer"))),
    );
    bindings.extend(
        shortcuts.select_all_diff_rows.iter().map(|shortcut| {
            KeyBinding::new(shortcut.as_str(), SelectAllDiffRows, Some("DiffViewer"))
        }),
    );
    bindings.extend(
        shortcuts
            .next_hunk
            .iter()
            .map(|shortcut| KeyBinding::new(shortcut.as_str(), NextHunk, Some("DiffViewer"))),
    );
    bindings.extend(
        shortcuts
            .previous_hunk
            .iter()
            .map(|shortcut| KeyBinding::new(shortcut.as_str(), PreviousHunk, Some("DiffViewer"))),
    );
    bindings.extend(
        shortcuts
            .next_file
            .iter()
            .map(|shortcut| KeyBinding::new(shortcut.as_str(), NextFile, Some("DiffViewer"))),
    );
    bindings.extend(
        shortcuts
            .previous_file
            .iter()
            .map(|shortcut| KeyBinding::new(shortcut.as_str(), PreviousFile, Some("DiffViewer"))),
    );
    bindings.extend(
        shortcuts.toggle_sidebar_tree.iter().map(|shortcut| {
            KeyBinding::new(shortcut.as_str(), ToggleSidebarTree, Some("DiffViewer"))
        }),
    );
    bindings.extend(
        shortcuts
            .open_project
            .iter()
            .map(|shortcut| KeyBinding::new(shortcut.as_str(), OpenProject, None)),
    );
    bindings.extend(
        shortcuts
            .save_current_file
            .iter()
            .map(|shortcut| KeyBinding::new(shortcut.as_str(), SaveCurrentFile, None)),
    );
    bindings.extend(
        shortcuts
            .open_settings
            .iter()
            .map(|shortcut| KeyBinding::new(shortcut.as_str(), OpenSettings, None)),
    );
    bindings.extend(
        shortcuts
            .quit_app
            .iter()
            .map(|shortcut| KeyBinding::new(shortcut.as_str(), QuitApp, None)),
    );

    cx.bind_keys(bindings);
}

pub fn run() -> Result<()> {
    let app = Application::new().with_assets(Assets);
    let keyboard_shortcuts = load_keyboard_shortcuts();
    app.on_reopen(|cx| {
        if cx.windows().is_empty() {
            open_main_window(cx);
        }
        cx.activate(true);
    });

    app.run(move |cx| {
        gpui_component::init(cx);
        apply_soft_light_theme(cx);
        apply_soft_dark_theme(cx);
        cx.on_action(quit_app);
        bind_keyboard_shortcuts(cx, &keyboard_shortcuts);
        cx.set_menus(build_application_menus());
        cx.activate(true);
        open_main_window(cx);
    });

    Ok(())
}

fn open_main_window(cx: &mut App) {
    let window_options = WindowOptions {
        titlebar: Some(TitlebarOptions {
            title: Some("Hunk".into()),
            ..Default::default()
        }),
        ..Default::default()
    };

    if let Err(err) = cx.open_window(window_options, |window, cx| {
        let view = cx.new(|cx| DiffViewer::new(window, cx));
        cx.new(|cx| Root::new(view, window, cx))
    }) {
        error!("failed to open window: {err:#}");
    }
}

fn quit_app(_: &QuitApp, cx: &mut App) {
    cx.quit();
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
enum SettingsCategory {
    Ui,
    KeyboardShortcuts,
}

impl SettingsCategory {
    const ALL: [Self; 2] = [Self::Ui, Self::KeyboardShortcuts];

    fn title(self) -> &'static str {
        match self {
            Self::Ui => "UI",
            Self::KeyboardShortcuts => "Keyboard Shortcuts",
        }
    }
}

#[derive(Clone)]
struct SettingsShortcutRow {
    id: &'static str,
    label: &'static str,
    hint: &'static str,
    input_state: Entity<InputState>,
}

#[derive(Clone)]
struct SettingsShortcutInputs {
    select_next_line: Entity<InputState>,
    select_previous_line: Entity<InputState>,
    extend_selection_next_line: Entity<InputState>,
    extend_selection_previous_line: Entity<InputState>,
    copy_selection: Entity<InputState>,
    select_all_diff_rows: Entity<InputState>,
    next_hunk: Entity<InputState>,
    previous_hunk: Entity<InputState>,
    next_file: Entity<InputState>,
    previous_file: Entity<InputState>,
    toggle_sidebar_tree: Entity<InputState>,
    open_project: Entity<InputState>,
    save_current_file: Entity<InputState>,
    open_settings: Entity<InputState>,
    quit_app: Entity<InputState>,
}

impl SettingsShortcutInputs {
    fn rows(&self) -> Vec<SettingsShortcutRow> {
        vec![
            SettingsShortcutRow {
                id: "select-next-line",
                label: "Select Next Line",
                hint: "Moves selection down one diff row.",
                input_state: self.select_next_line.clone(),
            },
            SettingsShortcutRow {
                id: "select-previous-line",
                label: "Select Previous Line",
                hint: "Moves selection up one diff row.",
                input_state: self.select_previous_line.clone(),
            },
            SettingsShortcutRow {
                id: "extend-selection-next-line",
                label: "Extend Selection Down",
                hint: "Extends the multi-row selection downward.",
                input_state: self.extend_selection_next_line.clone(),
            },
            SettingsShortcutRow {
                id: "extend-selection-previous-line",
                label: "Extend Selection Up",
                hint: "Extends the multi-row selection upward.",
                input_state: self.extend_selection_previous_line.clone(),
            },
            SettingsShortcutRow {
                id: "copy-selection",
                label: "Copy Selection",
                hint: "Copies the selected diff rows.",
                input_state: self.copy_selection.clone(),
            },
            SettingsShortcutRow {
                id: "select-all-diff-rows",
                label: "Select All Diff Rows",
                hint: "Selects all rows in the current diff.",
                input_state: self.select_all_diff_rows.clone(),
            },
            SettingsShortcutRow {
                id: "next-hunk",
                label: "Next Hunk",
                hint: "Jumps to the next diff hunk.",
                input_state: self.next_hunk.clone(),
            },
            SettingsShortcutRow {
                id: "previous-hunk",
                label: "Previous Hunk",
                hint: "Jumps to the previous diff hunk.",
                input_state: self.previous_hunk.clone(),
            },
            SettingsShortcutRow {
                id: "next-file",
                label: "Next File",
                hint: "Moves to the next changed file.",
                input_state: self.next_file.clone(),
            },
            SettingsShortcutRow {
                id: "previous-file",
                label: "Previous File",
                hint: "Moves to the previous changed file.",
                input_state: self.previous_file.clone(),
            },
            SettingsShortcutRow {
                id: "toggle-sidebar-tree",
                label: "Toggle File Tree",
                hint: "Collapses or expands the left file tree pane.",
                input_state: self.toggle_sidebar_tree.clone(),
            },
            SettingsShortcutRow {
                id: "open-project",
                label: "Open Project",
                hint: "Opens the system project picker.",
                input_state: self.open_project.clone(),
            },
            SettingsShortcutRow {
                id: "save-current-file",
                label: "Save Current File",
                hint: "Saves the active file editor buffer.",
                input_state: self.save_current_file.clone(),
            },
            SettingsShortcutRow {
                id: "open-settings",
                label: "Open Settings",
                hint: "Opens this settings popup.",
                input_state: self.open_settings.clone(),
            },
            SettingsShortcutRow {
                id: "quit-app",
                label: "Quit App",
                hint: "Quits Hunk.",
                input_state: self.quit_app.clone(),
            },
        ]
    }
}

#[derive(Clone)]
struct SettingsDraft {
    category: SettingsCategory,
    theme: ThemePreference,
    show_whitespace: bool,
    show_eol_markers: bool,
    shortcuts: SettingsShortcutInputs,
    error_message: Option<String>,
}

fn shortcut_lines(values: &[String]) -> String {
    values.join(", ")
}

fn parse_shortcut_lines(value: &str) -> Vec<String> {
    let mut shortcuts = Vec::new();
    let mut token = String::new();
    let mut previous_non_whitespace = None;

    for character in value.chars() {
        let is_separator =
            character == '\n' || (character == ',' && previous_non_whitespace != Some('-'));
        if is_separator {
            let trimmed = token.trim();
            if !trimmed.is_empty() {
                shortcuts.push(trimmed.to_owned());
            }
            token.clear();
            previous_non_whitespace = Some(character);
            continue;
        }

        token.push(character);
        if !character.is_whitespace() {
            previous_non_whitespace = Some(character);
        }
    }

    let trimmed = token.trim();
    if !trimmed.is_empty() {
        shortcuts.push(trimmed.to_owned());
    }

    shortcuts
}

struct DiffViewer {
    config_store: Option<ConfigStore>,
    config: AppConfig,
    settings_draft: Option<SettingsDraft>,
    state_store: Option<AppStateStore>,
    state: AppState,
    project_path: Option<PathBuf>,
    repo_root: Option<PathBuf>,
    branch_name: String,
    branch_has_upstream: bool,
    branch_ahead_count: usize,
    branches: Vec<LocalBranch>,
    bookmark_revisions: Vec<BookmarkRevision>,
    files: Vec<ChangedFile>,
    branch_picker_open: bool,
    branch_input_state: Entity<InputState>,
    commit_input_state: Entity<InputState>,
    commit_excluded_files: BTreeSet<String>,
    last_commit_subject: Option<String>,
    git_action_epoch: usize,
    git_action_task: Task<()>,
    git_action_loading: bool,
    git_status_message: Option<String>,
    collapsed_files: BTreeSet<String>,
    selected_path: Option<String>,
    selected_status: Option<FileStatus>,
    diff_rows: Vec<SideBySideRow>,
    diff_row_metadata: Vec<DiffStreamRowMeta>,
    diff_row_segment_cache: Vec<Option<DiffRowSegmentCache>>,
    diff_visible_file_header_lookup: Vec<Option<usize>>,
    diff_visible_hunk_header_lookup: Vec<Option<usize>>,
    file_row_ranges: Vec<FileRowRange>,
    file_line_stats: BTreeMap<String, LineStats>,
    diff_list_state: ListState,
    diff_show_whitespace: bool,
    diff_show_eol_markers: bool,
    diff_left_line_number_width: f32,
    diff_right_line_number_width: f32,
    overall_line_stats: LineStats,
    refresh_epoch: usize,
    auto_refresh_task: Task<()>,
    snapshot_epoch: usize,
    snapshot_task: Task<()>,
    snapshot_loading: bool,
    last_snapshot_fingerprint: Option<RepoSnapshotFingerprint>,
    open_project_task: Task<()>,
    patch_epoch: usize,
    patch_task: Task<()>,
    patch_loading: bool,
    in_app_menu_bar: Option<Entity<AppMenuBar>>,
    focus_handle: FocusHandle,
    selection_anchor_row: Option<usize>,
    selection_head_row: Option<usize>,
    drag_selecting_rows: bool,
    scroll_selected_after_reload: bool,
    last_visible_row_start: Option<usize>,
    last_diff_scroll_offset: Option<gpui::Point<gpui::Pixels>>,
    last_scroll_activity_at: Instant,
    segment_prefetch_anchor_row: Option<usize>,
    segment_prefetch_epoch: usize,
    segment_prefetch_task: Task<()>,
    fps: f32,
    frame_sample_count: u32,
    frame_sample_started_at: Instant,
    fps_epoch: usize,
    fps_task: Task<()>,
    repo_discovery_failed: bool,
    error_message: Option<String>,
    sidebar_collapsed: bool,
    workspace_view_mode: WorkspaceViewMode,
    sidebar_repo_list_state: ListState,
    sidebar_repo_row_count: usize,
    repo_tree_nodes: Vec<RepoTreeNode>,
    repo_tree_rows: Vec<RepoTreeRow>,
    repo_tree_file_count: usize,
    repo_tree_folder_count: usize,
    repo_tree_expanded_dirs: BTreeSet<String>,
    repo_tree_epoch: usize,
    repo_tree_task: Task<()>,
    repo_tree_loading: bool,
    repo_tree_error: Option<String>,
    right_pane_mode: RightPaneMode,
    editor_input_state: Entity<InputState>,
    editor_path: Option<String>,
    editor_loading: bool,
    editor_error: Option<String>,
    editor_dirty: bool,
    editor_last_saved_text: Option<String>,
    editor_epoch: usize,
    editor_task: Task<()>,
    editor_save_loading: bool,
    editor_save_epoch: usize,
    editor_save_task: Task<()>,
}
